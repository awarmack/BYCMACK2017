{
    "collab_server" : "",
    "contents" : "#summardize by time\nlibrary(dplyr)\nlibrary(tidyr)\noptions(scipen=999)\n\n#Summarise by second, 5 seconds\nrm(list=ls())\n\nload(\"./dat/alldat.RDATA\")\n\n\n#summarise by minute\n\nalldat$TIME.M <- as.POSIXct(round(alldat$TIME.S, \"mins\"))\nalldat$TIME.S <- as.POSIXct(round(alldat$TIME.S, \"secs\"))\n\n#get performance data\n\n#summarise by minute\n\nalldat$TIME.M <- as.POSIXct(round(alldat$TIME.S, \"mins\"))\nalldat$TIME.S <- as.POSIXct(round(alldat$TIME.S, \"secs\"))\n\n#summarise Performance Data by Minute\nperf <- alldat %>% group_by(TIME.M) %>% summarise(SOG=mean(GPS.SOG, na.rm = TRUE), \n                                                  AWS=mean(AWS, na.rm = TRUE), \n                                                  AWA=mean(AWA, na.rm = TRUE), \n                                                  COG=mean(GPS.COG, na.rm=TRUE), \n                                                  LAT=mean(GGA.LAT, na.rm=TRUE),\n                                                  LON=mean(GGA.LON, na.rm=TRUE))\n\n#remove any over 180 and convert \nperf$AWA[perf$AWA > 180] <- 360 - perf$AWA[perf$AWA > 180] \nperf <- perf[perf$AWA > 0, ] \n\n#convert Apparent to True\ngetTrueWind <- function(AWS, AWA, SOG) { \n  #outputs a list with \n  # $tws = True Wind Speed\n  # $twa = True Wind Angle\n  \n  b <- AWA * (pi/180)\n  \n  #true wind speed\n  TWS <- sqrt(AWS^2 + SOG^2 - 2*AWS*SOG*cos(b))\n  \n  \n  calcTWA <- function(b, AWS.b, SOG.b, W){\n    if(b > 0 & b<2*pi) {\n      \n      TWA <- acos(((AWS.b * cos(b)) - SOG.b)/W)\n      \n    } else {\n      if(b > 2*pi) {\n        TWA <- NA\n      }\n      \n      TWA <- -acos(AWS.b * cos(b) - SOG.b)\n      \n    }\n    \n    if(!is.na(TWA)){\n      \n      TWA <- TWA*180/pi\n      \n    }\n    return(TWA)\n  }\n  \n  TWA <- mapply(FUN=calcTWA, b, AWS, SOG, TWS)\n  \n  x <- list(TWS=TWS, TWA=TWA)\n  \n}\n\ntw <- getTrueWind(perf$AWS, perf$AWA, perf$SOG)\nperf$TWS <- tw$TWS\nperf$TWA <- tw$TWA\n\n\n#break wind speed into bins: \nperf$AWS.range <- cut(perf$AWS, breaks=c(0, 6, 8, 10, 12, 16, 20, 24, 35))\nperf$AWS.range <- factor(perf$AWS.range, levels=rev(levels(perf$AWS.range)))\nperf$TWS.range <- cut(perf$TWS, breaks=c(0, 6, 8, 10, 12, 16, 20, 24, 35))\nperf$TWS.range <- factor(perf$TWS.range, levels=rev(levels(perf$TWS.range)))\n\n#break wind angle into bins:\nperf$AWA.range <- cut(perf$AWA, breaks=seq(0,180, by=30))\nperf$TWA.range <- cut(perf$AWA, breaks=seq(0,180, by=30))\n\nlibrary(akima)\nlibrary(dplyr)\n\n#load Polars\npolars <- read.csv(\"./dat/polars/fullpolar.csv\")\n\n#remove optimum points\nopt <- polars[grep(\"OPT\", polars$SAIL), ]\npolars <- polars[-grep(\"OPT\", polars$SAIL),  ]\n\n#get the maximum V (velocity) for each wind speed and angle\npol <- polars %>% group_by(VTW, BTW) %>% summarise(V=max(V))\n\n#rejoin to the sail and heel data\npol <- left_join(pol, polars)\n\n#pol.0 <- data.frame(VTW = 0, BTW = 32:180, V=0, VAW=0, BAW=0, VMG=0, PHI=0, SAIL=\"Jib\")\n\n#pol <- rbind(pol, pol.0)\n\n\n# get the polar targets\npol.targets <- interpp(x=pol$VTW, \n                       y=pol$BTW, \n                       z=pol$V, \n                       xo = perf$TWS, \n                       yo= perf$TWA,\n                       linear=FALSE,\n                       extrap=FALSE,\n                       duplicate = \"mean\")\n\n#Calculate Measurables\nperf$target.SOG <- pol.targets$z\nperf$diff.SOG <- perf$SOG - perf$target.SOG\nperf$pol.perc <- (perf$SOG / perf$target.SOG) * 100\n\n\n\nwrite.csv(perf, \"./dat/data_byminute.csv\", row.names = FALSE)\n",
    "created" : 1502414409494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1069410058",
    "id" : "D26B16BA",
    "lastKnownWriteTime" : 1502483546,
    "last_content_update" : 1502483546759,
    "path" : "C:/Users/AWarmack/Dropbox/projects/sailing/BYCMACK2017/src/loadData.R",
    "project_path" : "src/loadData.R",
    "properties" : {
        "source_window_id" : ""
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}